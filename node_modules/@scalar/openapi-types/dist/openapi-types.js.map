{
  "version": 3,
  "sources": ["../src/openapi-types.ts"],
  "sourcesContent": ["/**\n * These types are copied from openapi-types, with two modifications:\n *\n * - all attributes are optional, you can't rely on the specification for user input\n * - extensions (basically any attributes, not only prefixed with an `x-`) are allowed\n *\n * We deal with user input and can't assume they really stick to any official specification.\n */\n\n/** any other attribute, for example x-* extensions */\ntype AnyOtherAttribute = {\n  /** OpenAPI extension */\n  [customExtension: `x-${string}`]: any\n  /** Unknown attribute */\n  [key: string]: any\n}\n\n// biome-ignore lint/style/noNamespace: We want it to be a module here.\nexport namespace OpenAPI {\n  // OpenAPI extensions can be declared using generics\n  // e.g.:\n  // OpenAPI.Document<{\n  //   'x-foobar': Foobar\n  // }>\n  export type Document<T extends AnyOtherAttribute = {}> =\n    | OpenAPIV2.Document<T>\n    | OpenAPIV3.Document<T>\n    | OpenAPIV3_1.Document<T>\n\n  export type Operation<T = {}> =\n    | OpenAPIV2.OperationObject<T>\n    | OpenAPIV3.OperationObject<T>\n    | OpenAPIV3_1.OperationObject<T>\n\n  export type Request = {\n    body?: any\n    headers?: object\n    params?: object\n    query?: object\n  }\n\n  export type ResponseObject = OpenAPIV2.ResponseObject | OpenAPIV3.ResponseObject | OpenAPIV3_1.ResponseObject\n\n  export type HeaderObject = OpenAPIV2.HeaderObject | OpenAPIV3.HeaderObject | OpenAPIV3_1.HeaderObject\n\n  export type Parameter =\n    | OpenAPIV3_1.ReferenceObject\n    | OpenAPIV3_1.ParameterObject\n    | OpenAPIV3.ReferenceObject\n    | OpenAPIV3.ParameterObject\n    | OpenAPIV2.ReferenceObject\n    | OpenAPIV2.Parameter\n\n  export type Parameters =\n    | (OpenAPIV3_1.ReferenceObject | OpenAPIV3_1.ParameterObject)[]\n    | (OpenAPIV3.ReferenceObject | OpenAPIV3.ParameterObject)[]\n    | (OpenAPIV2.ReferenceObject | OpenAPIV2.Parameter)[]\n\n  export type ExampleObject = OpenAPIV2.ExampleObject | OpenAPIV3.ExampleObject | OpenAPIV3_1.ExampleObject\n\n  export type SchemaObject = OpenAPIV2.SchemaObject | OpenAPIV3.SchemaObject | OpenAPIV3_1.SchemaObject\n\n  export type HttpMethod = keyof typeof OpenAPIV2.HttpMethods | OpenAPIV3.HttpMethods | OpenAPIV3_1.HttpMethods\n}\n\n// biome-ignore lint/style/noNamespace: We want it to be a module here.\nexport namespace OpenAPIV3_1 {\n  type Modify<T, R> = Omit<T, keyof R> & R\n\n  type PathsWebhooksComponents<T = {}> = {\n    paths?: PathsObject<T>\n    webhooks?: Record<string, PathItemObject | ReferenceObject>\n    components?: ComponentsObject\n  }\n\n  export type Document<T = {}> = Modify<\n    Omit<OpenAPIV3.Document<T>, 'paths' | 'components'>,\n    {\n      /**\n       * Version of the OpenAPI specification\n       * @see https://github.com/OAI/OpenAPI-Specification/tree/main/versions\n       */\n      openapi?: '3.1.0' | '3.1.1'\n      swagger?: undefined\n      info?: InfoObject\n      jsonSchemaDialect?: string\n      servers?: ServerObject[]\n    } & (\n      | (Pick<PathsWebhooksComponents<T>, 'paths'> & Omit<Partial<PathsWebhooksComponents<T>>, 'paths'>)\n      | (Pick<PathsWebhooksComponents<T>, 'webhooks'> & Omit<Partial<PathsWebhooksComponents<T>>, 'webhooks'>)\n      | (Pick<PathsWebhooksComponents<T>, 'components'> & Omit<Partial<PathsWebhooksComponents<T>>, 'components'>)\n    ) &\n      T &\n      AnyOtherAttribute\n  >\n\n  export type InfoObject = Modify<\n    OpenAPIV3.InfoObject,\n    {\n      summary?: string\n      license?: LicenseObject\n    }\n  >\n\n  export type ContactObject = OpenAPIV3.ContactObject\n\n  export type LicenseObject = Modify<\n    OpenAPIV3.LicenseObject,\n    {\n      identifier?: string\n    }\n  >\n\n  export type ServerObject = Modify<\n    OpenAPIV3.ServerObject,\n    {\n      url?: string\n      description?: string\n      variables?: Record<string, ServerVariableObject>\n    }\n  >\n\n  export type ServerVariableObject = Modify<\n    OpenAPIV3.ServerVariableObject,\n    {\n      enum?: [string, ...string[]]\n    }\n  >\n\n  export type PathsObject<T = {}, P extends {} = {}> = Record<string, (PathItemObject<T> & P) | undefined>\n\n  export type HttpMethods = OpenAPIV3.HttpMethods\n\n  export type PathItemObject<T = {}> = Modify<\n    OpenAPIV3.PathItemObject<T>,\n    {\n      servers?: ServerObject[]\n      parameters?: (ReferenceObject | ParameterObject)[]\n    }\n  > & {\n    [method in HttpMethods]?: OperationObject<T>\n  }\n\n  export type OperationObject<T = {}> = Modify<\n    OpenAPIV3.OperationObject<T>,\n    {\n      parameters?: (ReferenceObject | ParameterObject)[]\n      requestBody?: ReferenceObject | RequestBodyObject\n      responses?: ResponsesObject\n      callbacks?: Record<string, ReferenceObject | CallbackObject>\n      servers?: ServerObject[]\n    }\n  > &\n    T\n\n  export type ExternalDocumentationObject = OpenAPIV3.ExternalDocumentationObject\n\n  export type ParameterObject = OpenAPIV3.ParameterObject\n\n  export type HeaderObject = OpenAPIV3.HeaderObject\n\n  export type ParameterBaseObject = OpenAPIV3.ParameterBaseObject\n\n  export type NonArraySchemaObjectType = OpenAPIV3.NonArraySchemaObjectType | 'null'\n\n  export type ArraySchemaObjectType = OpenAPIV3.ArraySchemaObjectType\n\n  /**\n   * There is no way to tell typescript to require items when type is either 'array' or array containing 'array' type\n   * 'items' will be always visible as optional\n   * Casting schema object to ArraySchemaObject or NonArraySchemaObject will work fine\n   */\n  export type SchemaObject = (ArraySchemaObject | NonArraySchemaObject | MixedSchemaObject | boolean) &\n    AnyOtherAttribute\n\n  export type ArraySchemaObject = {\n    type?: ArraySchemaObjectType\n    items?: ReferenceObject | SchemaObject\n  } & BaseSchemaObject\n\n  export type NonArraySchemaObject = {\n    type?: NonArraySchemaObjectType\n  } & BaseSchemaObject\n\n  type MixedSchemaObject = {\n    type?: (ArraySchemaObjectType | NonArraySchemaObjectType)[]\n    items?: ReferenceObject | SchemaObject\n  } & BaseSchemaObject\n\n  export type BaseSchemaObject = Modify<\n    Omit<OpenAPIV3.BaseSchemaObject, 'nullable'>,\n    {\n      examples?: OpenAPIV3.BaseSchemaObject['example'][]\n      exclusiveMinimum?: boolean | number\n      exclusiveMaximum?: boolean | number\n      contentMediaType?: string\n      $schema?: string\n      additionalProperties?: boolean | ReferenceObject | SchemaObject\n      properties?: {\n        [name: string]: ReferenceObject | SchemaObject\n      }\n      patternProperties?: {\n        [name: string]: ReferenceObject | SchemaObject\n      }\n      allOf?: (ReferenceObject | SchemaObject)[]\n      oneOf?: (ReferenceObject | SchemaObject)[]\n      anyOf?: (ReferenceObject | SchemaObject)[]\n      not?: ReferenceObject | SchemaObject\n      discriminator?: DiscriminatorObject\n      externalDocs?: ExternalDocumentationObject\n      xml?: XMLObject\n      const?: any\n    }\n  >\n\n  export type DiscriminatorObject = OpenAPIV3.DiscriminatorObject\n\n  export type XMLObject = OpenAPIV3.XMLObject\n\n  export type ReferenceObject = Modify<\n    OpenAPIV3.ReferenceObject,\n    {\n      summary?: string\n      description?: string\n    }\n  >\n\n  export type ExampleObject = OpenAPIV3.ExampleObject\n\n  export type MediaTypeObject = Modify<\n    OpenAPIV3.MediaTypeObject,\n    {\n      schema?: SchemaObject | ReferenceObject\n      examples?: Record<string, ReferenceObject | ExampleObject>\n    }\n  >\n\n  export type EncodingObject = OpenAPIV3.EncodingObject\n\n  export type RequestBodyObject = Modify<\n    OpenAPIV3.RequestBodyObject,\n    {\n      content?: { [media: string]: MediaTypeObject }\n    }\n  >\n\n  export type ResponsesObject = Record<string, ReferenceObject | ResponseObject>\n\n  export type ResponseObject = Modify<\n    OpenAPIV3.ResponseObject,\n    {\n      headers?: { [header: string]: ReferenceObject | HeaderObject }\n      content?: { [media: string]: MediaTypeObject }\n      links?: { [link: string]: ReferenceObject | LinkObject }\n    }\n  >\n\n  export type LinkObject = Modify<\n    OpenAPIV3.LinkObject,\n    {\n      server?: ServerObject\n    }\n  >\n\n  export type CallbackObject = Record<string, PathItemObject | ReferenceObject>\n\n  export type SecurityRequirementObject = OpenAPIV3.SecurityRequirementObject\n\n  export type ComponentsObject = Modify<\n    OpenAPIV3.ComponentsObject,\n    {\n      schemas?: Record<string, SchemaObject>\n      responses?: Record<string, ReferenceObject | ResponseObject>\n      parameters?: Record<string, ReferenceObject | ParameterObject>\n      examples?: Record<string, ReferenceObject | ExampleObject>\n      requestBodies?: Record<string, ReferenceObject | RequestBodyObject>\n      headers?: Record<string, ReferenceObject | HeaderObject>\n      securitySchemes?: Record<string, ReferenceObject | SecuritySchemeObject>\n      links?: Record<string, ReferenceObject | LinkObject>\n      callbacks?: Record<string, ReferenceObject | CallbackObject>\n      pathItems?: Record<string, ReferenceObject | PathItemObject>\n    }\n  >\n\n  export type SecuritySchemeObject = OpenAPIV3.SecuritySchemeObject\n\n  export type HttpSecurityScheme = OpenAPIV3.HttpSecurityScheme\n\n  export type ApiKeySecurityScheme = OpenAPIV3.ApiKeySecurityScheme\n\n  export type OAuth2SecurityScheme = OpenAPIV3.OAuth2SecurityScheme\n\n  export type OpenIdSecurityScheme = OpenAPIV3.OpenIdSecurityScheme\n\n  export type TagObject = OpenAPIV3.TagObject\n}\n\n// biome-ignore lint/style/noNamespace: We want it to be a module here.\nexport namespace OpenAPIV3 {\n  export type Document<T = {}> = {\n    /**\n     * Version of the OpenAPI specification\n     * @see https://github.com/OAI/OpenAPI-Specification/tree/main/versions\n     */\n    openapi?: '3.0.0' | '3.0.1' | '3.0.2' | '3.0.3' | '3.0.4'\n    swagger?: undefined\n    info?: InfoObject\n    servers?: ServerObject[]\n    paths?: PathsObject<T>\n    components?: ComponentsObject\n    security?: SecurityRequirementObject[]\n    tags?: TagObject[]\n    externalDocs?: ExternalDocumentationObject\n  } & T &\n    AnyOtherAttribute\n\n  export type InfoObject = {\n    title?: string\n    description?: string\n    termsOfService?: string\n    contact?: ContactObject\n    license?: LicenseObject\n    version?: string\n  }\n\n  export type ContactObject = {\n    name?: string\n    url?: string\n    email?: string\n  }\n\n  export type LicenseObject = {\n    name?: string\n    url?: string\n  }\n\n  export type ServerObject = {\n    url?: string\n    description?: string\n    variables?: { [variable: string]: ServerVariableObject }\n  }\n\n  export type ServerVariableObject = {\n    enum?: string[] | number[]\n    default?: string | number\n    description?: string\n  }\n\n  export type PathsObject<T = {}, P extends {} = {}> = {\n    [pattern: string]: (PathItemObject<T> & P) | undefined\n  }\n\n  // All HTTP methods allowed by OpenAPI 3 spec\n  // See https://swagger.io/specification/#path-item-object\n  // You can use keys or values from it in TypeScript code like this:\n  //     for (const method of Object.values(OpenAPIV3.HttpMethods)) { \u2026 }\n  export type HttpMethods = 'get' | 'put' | 'post' | 'delete' | 'options' | 'head' | 'patch' | 'trace' | 'connect'\n\n  export type PathItemObject<T = {}> = {\n    $ref?: string\n    summary?: string\n    description?: string\n    servers?: ServerObject[]\n    parameters?: (ReferenceObject | ParameterObject)[]\n  } & {\n    [method in HttpMethods]?: OperationObject<T>\n  } & T &\n    AnyOtherAttribute\n\n  export type OperationObject<T = {}> = {\n    tags?: string[]\n    summary?: string\n    description?: string\n    externalDocs?: ExternalDocumentationObject\n    operationId?: string\n    parameters?: (ReferenceObject | ParameterObject)[]\n    requestBody?: ReferenceObject | RequestBodyObject\n    responses?: ResponsesObject\n    callbacks?: { [callback: string]: ReferenceObject | CallbackObject }\n    deprecated?: boolean\n    security?: SecurityRequirementObject[]\n    servers?: ServerObject[]\n  } & T &\n    AnyOtherAttribute\n\n  export type ExternalDocumentationObject = {\n    description?: string\n    url?: string\n  }\n\n  export type ParameterObject = {\n    name?: string\n    in?: string\n  } & ParameterBaseObject\n\n  export type HeaderObject = {} & ParameterBaseObject\n\n  export type ParameterBaseObject = {\n    description?: string\n    required?: boolean\n    deprecated?: boolean\n    allowEmptyValue?: boolean\n    style?: string\n    explode?: boolean\n    allowReserved?: boolean\n    schema?: ReferenceObject | SchemaObject\n    example?: any\n    examples?: { [media: string]: ReferenceObject | ExampleObject }\n    content?: { [media: string]: MediaTypeObject }\n  }\n  export type NonArraySchemaObjectType = 'boolean' | 'object' | 'number' | 'string' | 'integer'\n  export type ArraySchemaObjectType = 'array'\n  export type SchemaObject = (ArraySchemaObject | NonArraySchemaObject) & AnyOtherAttribute\n\n  export type ArraySchemaObject = {\n    type?: ArraySchemaObjectType\n    items?: ReferenceObject | SchemaObject\n  } & BaseSchemaObject\n\n  export type NonArraySchemaObject = {\n    type?: NonArraySchemaObjectType\n  } & BaseSchemaObject\n\n  export type BaseSchemaObject = {\n    // JSON schema allowed properties, adjusted for OpenAPI\n    title?: string\n    description?: string\n    format?: string\n    default?: any\n    multipleOf?: number\n    maximum?: number\n    exclusiveMaximum?: boolean\n    minimum?: number\n    exclusiveMinimum?: boolean\n    maxLength?: number\n    minLength?: number\n    pattern?: string\n    additionalProperties?: boolean | ReferenceObject | SchemaObject\n    maxItems?: number\n    minItems?: number\n    uniqueItems?: boolean\n    maxProperties?: number\n    minProperties?: number\n    required?: string[]\n    enum?: any[]\n    properties?: {\n      [name: string]: ReferenceObject | SchemaObject\n    }\n    patternProperties?: {\n      [name: string]: ReferenceObject | SchemaObject\n    }\n    allOf?: (ReferenceObject | SchemaObject)[]\n    oneOf?: (ReferenceObject | SchemaObject)[]\n    anyOf?: (ReferenceObject | SchemaObject)[]\n    not?: ReferenceObject | SchemaObject\n\n    // OpenAPI-specific properties\n    nullable?: boolean\n    discriminator?: DiscriminatorObject\n    readOnly?: boolean\n    writeOnly?: boolean\n    xml?: XMLObject\n    externalDocs?: ExternalDocumentationObject\n    example?: any\n    deprecated?: boolean\n  }\n\n  export type DiscriminatorObject = {\n    propertyName?: string\n    mapping?: { [value: string]: string }\n  }\n\n  export type XMLObject = {\n    name?: string\n    namespace?: string\n    prefix?: string\n    attribute?: boolean\n    wrapped?: boolean\n  }\n\n  export type ReferenceObject = {\n    $ref?: string\n  } & AnyOtherAttribute\n\n  export type ExampleObject = {\n    summary?: string\n    description?: string\n    value?: any\n    externalValue?: string\n  }\n\n  export type MediaTypeObject = {\n    schema?: ReferenceObject | SchemaObject\n    example?: any\n    examples?: { [media: string]: ReferenceObject | ExampleObject }\n    encoding?: { [media: string]: EncodingObject }\n  }\n\n  export type EncodingObject = {\n    contentType?: string\n    headers?: { [header: string]: ReferenceObject | HeaderObject }\n    style?: string\n    explode?: boolean\n    allowReserved?: boolean\n  }\n\n  export type RequestBodyObject = {\n    description?: string\n    content?: { [media: string]: MediaTypeObject }\n    required?: boolean\n  }\n\n  export type ResponsesObject = {\n    [code: string]: ReferenceObject | ResponseObject\n  }\n\n  export type ResponseObject = {\n    description?: string\n    headers?: { [header: string]: ReferenceObject | HeaderObject }\n    content?: { [media: string]: MediaTypeObject }\n    links?: { [link: string]: ReferenceObject | LinkObject }\n  } & AnyOtherAttribute\n\n  export type LinkObject = {\n    operationRef?: string\n    operationId?: string\n    parameters?: { [parameter: string]: any }\n    requestBody?: any\n    description?: string\n    server?: ServerObject\n  }\n\n  export type CallbackObject = {\n    [url: string]: PathItemObject\n  }\n\n  export type SecurityRequirementObject = {\n    [name: string]: string[]\n  }\n\n  export type ComponentsObject = {\n    schemas?: { [key: string]: ReferenceObject | SchemaObject }\n    responses?: { [key: string]: ReferenceObject | ResponseObject }\n    parameters?: { [key: string]: ReferenceObject | ParameterObject }\n    examples?: { [key: string]: ReferenceObject | ExampleObject }\n    requestBodies?: { [key: string]: ReferenceObject | RequestBodyObject }\n    headers?: { [key: string]: ReferenceObject | HeaderObject }\n    securitySchemes?: { [key: string]: ReferenceObject | SecuritySchemeObject }\n    links?: { [key: string]: ReferenceObject | LinkObject }\n    callbacks?: { [key: string]: ReferenceObject | CallbackObject }\n  }\n\n  export type SecuritySchemeObject =\n    | HttpSecurityScheme\n    | ApiKeySecurityScheme\n    | OAuth2SecurityScheme\n    | OpenIdSecurityScheme\n\n  export type HttpSecurityScheme = {\n    type?: 'http'\n    description?: string\n    scheme?: string\n    bearerFormat?: string\n  } & AnyOtherAttribute\n\n  export type ApiKeySecurityScheme = {\n    type?: 'apiKey'\n    description?: string\n    name?: string\n    in?: string\n  } & AnyOtherAttribute\n\n  export type OAuth2SecurityScheme = {\n    type?: 'oauth2'\n    description?: string\n    flows?: {\n      implicit?: {\n        authorizationUrl?: string\n        refreshUrl?: string\n        scopes?: { [scope: string]: string }\n      } & AnyOtherAttribute\n      password?: {\n        tokenUrl?: string\n        refreshUrl?: string\n        scopes?: { [scope: string]: string }\n      } & AnyOtherAttribute\n      clientCredentials?: {\n        tokenUrl?: string\n        refreshUrl?: string\n        scopes?: { [scope: string]: string }\n      } & AnyOtherAttribute\n      authorizationCode?: {\n        authorizationUrl?: string\n        tokenUrl?: string\n        refreshUrl?: string\n        scopes?: { [scope: string]: string }\n      } & AnyOtherAttribute\n    }\n  }\n\n  export type OpenIdSecurityScheme = {\n    type?: 'openIdConnect'\n    description?: string\n    openIdConnectUrl?: string\n  } & AnyOtherAttribute\n\n  export type TagObject = {\n    name?: string\n    description?: string\n    externalDocs?: ExternalDocumentationObject\n  } & AnyOtherAttribute\n}\n\n// biome-ignore lint/style/noNamespace: We want it to be a module here.\nexport namespace OpenAPIV2 {\n  export type Document<T = {}> = {\n    /**\n     * Version of the OpenAPI specification\n     * @see https://github.com/OAI/OpenAPI-Specification/tree/main/versions\n     */\n    swagger?: '2.0'\n    openapi?: never\n    basePath?: string\n    consumes?: MimeTypes\n    definitions?: DefinitionsObject\n    externalDocs?: ExternalDocumentationObject\n    host?: string\n    info?: InfoObject\n    parameters?: ParametersDefinitionsObject\n    paths?: PathsObject<T>\n    produces?: MimeTypes\n    responses?: ResponsesDefinitionsObject\n    schemes?: string[]\n    security?: SecurityRequirementObject[]\n    securityDefinitions?: SecurityDefinitionsObject\n    tags?: TagObject[]\n  } & T &\n    AnyOtherAttribute\n\n  export type TagObject = {\n    name?: string\n    description?: string\n    externalDocs?: ExternalDocumentationObject\n  } & AnyOtherAttribute\n\n  export type SecuritySchemeObjectBase = {\n    type?: 'basic' | 'apiKey' | 'oauth2'\n    description?: string\n  }\n\n  export type SecuritySchemeBasic = {\n    type?: 'basic'\n  } & SecuritySchemeObjectBase\n\n  export type SecuritySchemeApiKey = {\n    type?: 'apiKey'\n    name?: string\n    in?: string\n  } & SecuritySchemeObjectBase\n\n  export type SecuritySchemeOauth2 =\n    | SecuritySchemeOauth2Implicit\n    | SecuritySchemeOauth2AccessCode\n    | SecuritySchemeOauth2Password\n    | SecuritySchemeOauth2Application\n\n  export type ScopesObject = {\n    [index: string]: any\n  }\n\n  export type SecuritySchemeOauth2Base = {\n    type?: 'oauth2'\n    flow?: 'implicit' | 'password' | 'application' | 'accessCode'\n    scopes?: ScopesObject\n  } & SecuritySchemeObjectBase\n\n  export type SecuritySchemeOauth2Implicit = {\n    flow?: 'implicit'\n    authorizationUrl?: string\n  } & SecuritySchemeOauth2Base\n\n  export type SecuritySchemeOauth2AccessCode = {\n    flow?: 'accessCode'\n    authorizationUrl?: string\n    tokenUrl?: string\n  } & SecuritySchemeOauth2Base\n\n  export type SecuritySchemeOauth2Password = {\n    flow?: 'password'\n    tokenUrl?: string\n  } & SecuritySchemeOauth2Base\n\n  export type SecuritySchemeOauth2Application = {\n    flow?: 'application'\n    tokenUrl?: string\n  } & SecuritySchemeOauth2Base\n\n  export type SecuritySchemeObject = SecuritySchemeBasic | SecuritySchemeApiKey | SecuritySchemeOauth2\n\n  export type SecurityDefinitionsObject = {\n    [index: string]: SecuritySchemeObject\n  }\n\n  export type SecurityRequirementObject = {\n    [index: string]: string[]\n  }\n\n  export type ReferenceObject = {\n    $ref: string\n  } & AnyOtherAttribute\n\n  export type Response = ResponseObject | ReferenceObject\n\n  export type ResponsesDefinitionsObject = {\n    [index: string]: ResponseObject\n  }\n\n  export type Schema = SchemaObject | ReferenceObject\n\n  export type ResponseObject = {\n    description?: string\n    schema?: Schema\n    headers?: HeadersObject\n    examples?: ExampleObject\n  } & AnyOtherAttribute\n\n  export type HeadersObject = {\n    [index: string]: HeaderObject\n  }\n\n  export type HeaderObject = {\n    description?: string\n  } & ItemsObject\n\n  export type ExampleObject = {\n    [index: string]: any\n  }\n\n  export type OperationObject<T = {}> = {\n    tags?: string[]\n    summary?: string\n    description?: string\n    externalDocs?: ExternalDocumentationObject\n    operationId?: string\n    consumes?: MimeTypes\n    produces?: MimeTypes\n    parameters?: Parameters\n    responses: ResponsesObject\n    schemes?: string[]\n    deprecated?: boolean\n    security?: SecurityRequirementObject[]\n  } & T &\n    AnyOtherAttribute\n\n  export type ResponsesObject = {\n    [index: string]: Response | undefined\n    default?: Response\n  }\n\n  export type Parameters = (ReferenceObject | Parameter)[]\n\n  export type Parameter = InBodyParameterObject | GeneralParameterObject\n\n  export type InBodyParameterObject = {\n    schema?: Schema\n  } & ParameterObject\n\n  export type GeneralParameterObject = {\n    allowEmptyValue?: boolean\n  } & ParameterObject &\n    ItemsObject\n\n  // All HTTP methods allowed by OpenAPI 2 spec\n  // See https://swagger.io/specification/v2#path-item-object\n  // You can use keys or values from it in TypeScript code like this:\n  //     for (const method of Object.values(OpenAPIV2.HttpMethods)) { \u2026 }\n  export enum HttpMethods {\n    GET = 'get',\n    PUT = 'put',\n    POST = 'post',\n    DELETE = 'delete',\n    OPTIONS = 'options',\n    HEAD = 'head',\n    PATCH = 'patch',\n  }\n\n  export type PathItemObject<T = {}> = {\n    $ref?: string\n    parameters?: Parameters\n  } & {\n    [method in HttpMethods]?: OperationObject<T>\n  }\n\n  export type PathsObject<T = {}> = {\n    [index: string]: PathItemObject<T>\n  }\n\n  export type ParametersDefinitionsObject = {\n    [index: string]: ParameterObject\n  }\n\n  export type ParameterObject = {\n    name?: string\n    in?: string\n    description?: string\n    required?: boolean\n    [index: string]: any\n  }\n\n  export type MimeTypes = string[]\n\n  export type DefinitionsObject = {\n    [index: string]: SchemaObject\n  }\n\n  export type SchemaObject = {\n    [index: string]: any\n    discriminator?: string\n    readOnly?: boolean\n    xml?: XMLObject\n    externalDocs?: ExternalDocumentationObject\n    example?: any\n    default?: any\n    items?: ItemsObject | ReferenceObject\n    properties?: {\n      [name: string]: SchemaObject\n    }\n  } & IJsonSchema\n\n  export type ExternalDocumentationObject = {\n    [index: string]: any\n    description?: string\n    url?: string\n  }\n\n  export type ItemsObject = {\n    type?: string\n    format?: string\n    items?: ItemsObject | ReferenceObject\n    collectionFormat?: string\n    default?: any\n    maximum?: number\n    exclusiveMaximum?: boolean\n    minimum?: number\n    exclusiveMinimum?: boolean\n    maxLength?: number\n    minLength?: number\n    pattern?: string\n    maxItems?: number\n    minItems?: number\n    uniqueItems?: boolean\n    enum?: any[]\n    multipleOf?: number\n    $ref?: string\n  }\n\n  export type XMLObject = {\n    [index: string]: any\n    name?: string\n    namespace?: string\n    prefix?: string\n    attribute?: boolean\n    wrapped?: boolean\n  }\n\n  export type InfoObject = {\n    title?: string\n    description?: string\n    termsOfService?: string\n    contact?: ContactObject\n    license?: LicenseObject\n    version?: string\n  }\n\n  export type ContactObject = {\n    name?: string\n    url?: string\n    email?: string\n  }\n\n  export type LicenseObject = {\n    name?: string\n    url?: string\n  }\n}\n\nexport type IJsonSchema = {\n  id?: string\n  $schema?: string\n  title?: string\n  description?: string\n  multipleOf?: number\n  maximum?: number\n  exclusiveMaximum?: boolean\n  minimum?: number\n  exclusiveMinimum?: boolean\n  maxLength?: number\n  minLength?: number\n  pattern?: string\n  additionalItems?: boolean | IJsonSchema\n  items?: IJsonSchema | IJsonSchema[]\n  maxItems?: number\n  minItems?: number\n  uniqueItems?: boolean\n  maxProperties?: number\n  minProperties?: number\n  required?: string[]\n  additionalProperties?: boolean | IJsonSchema\n  definitions?: {\n    [name: string]: IJsonSchema\n  }\n  properties?: {\n    [name: string]: IJsonSchema\n  }\n  patternProperties?: {\n    [name: string]: IJsonSchema\n  }\n  dependencies?: {\n    [name: string]: IJsonSchema | string[]\n  }\n  enum?: any[]\n  type?: string | string[]\n  allOf?: IJsonSchema[]\n  anyOf?: IJsonSchema[]\n  oneOf?: IJsonSchema[]\n  not?: IJsonSchema\n  $ref?: string\n} & AnyOtherAttribute\n"],
  "mappings": "AAsmBO,IAAU;AAAA,CAAV,CAAUA,eAAV;AAkKE,MAAK;AAAL,IAAKC,iBAAL;AACL,IAAAA,aAAA,SAAM;AACN,IAAAA,aAAA,SAAM;AACN,IAAAA,aAAA,UAAO;AACP,IAAAA,aAAA,YAAS;AACT,IAAAA,aAAA,aAAU;AACV,IAAAA,aAAA,UAAO;AACP,IAAAA,aAAA,WAAQ;AAAA,KAPE,cAAAD,WAAA,gBAAAA,WAAA;AAAA,GAlKG;",
  "names": ["OpenAPIV2", "HttpMethods"]
}
